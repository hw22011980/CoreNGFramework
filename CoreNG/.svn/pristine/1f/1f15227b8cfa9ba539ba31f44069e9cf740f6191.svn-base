import { Component, OnInit, Input, Output, EventEmitter, OnDestroy } from '@angular/core';
import { IconDefinition } from '@fortawesome/fontawesome-svg-core';
import { faFolderOpen, faFolder, faFile } from '@fortawesome/free-regular-svg-icons';
import { PublishDetailsService } from 'src/app/services/publish-details.service';
import { DeviceConnectStatus } from 'src/app/devices/shared/device-connect-status';
import { Subscription } from 'rxjs';
import { Envelop, ICrossComponentMsg, NavTreeNodeStatus } from 'src/app/common/cross-component-msg';


@Component({
  selector: 'app-nav-tree',
  templateUrl: './nav-tree.component.html',
  styleUrls: ['./nav-tree.component.css']
})
export class NavTreeComponent implements OnInit, ICrossComponentMsg, OnDestroy {

  public nodes: any[] = [];
  public node: any;
  public collapseAttr: string = "isCollapsed";
  public selectedAttr: string = "isSelected";
  public milestoneAttr: string = "milestone";
  public connectionStatus = false;
  public toolsSlideInOffline = false;
  private checkBoxAttr: string = "isCheckBoxChanged";
  envelop: Envelop


  xComponentSubscription: Subscription;

  /**
   * Providen data for tree.
   */
  @Input('data') data: any;


  /**
 * Providen full data for tree.
 */
  @Input('treeNodes') treeNodes: any;

  @Input('disableClick') disableClick: boolean = false;

  /**
   * Manipulation raw data to use for nav tree and prepare is required.
   * Default is true.
   */
  @Input('prepareData') prepareData: boolean = true;

  /**
   * Name of id property in input data.
   */
  @Input('idAttr') idAttr: string = "id";

  /**
   * Name of children list property in input data.
   */
  @Input('childrenAttr') childrenAttr: string = "children";

  /**
   * Name of enable control property in input data.
   */
  @Input('enabledAttr') disabledAttr: string = "enable";

  /**
   * Name of visible control property in input data.
   */
  @Input('visibleAttr') visibleAttr: string = "visible";



  @Input()
  public openedFolderIcon: IconDefinition = faFolderOpen;

  @Input()
  public closedFolderIcon: IconDefinition = faFolder;

  @Input()
  public leafFolderIcon: IconDefinition = faFile;

  @Input('collapseNode')
  set collapseNode(value: boolean) {
    if ((!this.connectionStatus) && (!this.toolsSlideInOffline))
      this._recursiveEdit(this.nodes, this.collapseAttr, true);
    this._recursiveEditByNode(
      this.nodes, this.node, this.collapseAttr, value);
  }

  @Input('selectedNode')
  set selectedNode(value: boolean) {
    this._recursiveEdit(this.nodes, this.selectedAttr, false);
    this._recursiveEditByNode(
      this.nodes, this.node, this.selectedAttr, value);
  }

  /**
   * On click node.
   */
  @Output() onClick = new EventEmitter<any>();

  @Output() onDataOut = new EventEmitter<any>();

  @Output() onParentNodeCheck = new EventEmitter<any>();


  constructor(private emitDetails: PublishDetailsService) {
    this.setEnvelop(null);
  }

  ngOnInit() {
    this.setEnvelop(null);
    this.connectionStatus = false;
    this.toolsSlideInOffline = true;
    this.updateTree(null);
    //connection status transition events 
    this.xComponentSubscription = this.emitDetails.messageEmitter.subscribe(data => this.onSubscribedData(data));

    //when user suddenly reloads, keep connections status
    if (localStorage.hasOwnProperty('previousId')) {
      const connectstatus: DeviceConnectStatus = JSON.parse(localStorage.getItem('previousId'));
      this.connectionStatus = connectstatus.isConnected;
    } else
      this.connectionStatus = false;

  }
  private updateTree(menu: any) {
    this.nodes = menu == null ? this._preparedData(this.data) : this._preparedData(menu);
  }


  ngOnDestroy() {
    this.xComponentSubscription.unsubscribe();
  }
  setEnvelop(data) {
    this.envelop = new Envelop('DeviceSetupComponent',
      'NavTreeComponent', 'Send selected checked box to DeviceSetupComponent', data);
  }

  private expandAll(value: boolean) {
    this._recursiveEdit(this.nodes, this.collapseAttr, !value);
  }

  private selectAll(value: string) {
    this._recursiveEditEx(this.nodes, this.milestoneAttr, "status", value);
  }


  onSubscribedData(data: any) {
    if (data instanceof Envelop) {
      const tempdata = data as Envelop;
      switch (tempdata.from) {
        case 'DeviceNavigationComponent':
        case 'ToolsComponent':
          {
            if (tempdata.get() instanceof DeviceConnectStatus) {
              const status = tempdata.get() as DeviceConnectStatus;
              this.connectionStatus = status.isConnected;
            }
            const status = tempdata.get(); // no instance checking to resolve circular dependency
            switch (status.EventName) {
              case 'updateNavTree': this.updateTree(status.Value); break;
              case 'toolsSlideInOffline': this.toolsSlideInOffline = status.Value; break;
              default: break;
            }
          }
          break;
        case 'DeviceSetupComponent':
          {
            const status = tempdata.get(); // no instance checking to resolve circular dependency
            switch (status.EventName) {
              case "openFolder": this.expandAll(status.Value); break;
              case "selectAll": this.selectAll(status.Value); break;
              case 'updateNavTree': this.updateTree(status.Value); break;
              case 'toolsSlideInOffline': this.toolsSlideInOffline = status.Value; break;
              default: break;
            }
          }
          break;
        default:
          break;
      }
    }
  }


  click(node) {

    this.node = node;
    this.selectedNode = true;
    if (node[this.childrenAttr].length)
      this.collapseNode = !node[this.collapseAttr];

    this.onDataOut.emit(this.GetNodesStatus());
    this.onClick.emit(node);
  }

  checkMilestone(node) {

    switch (node[this.milestoneAttr].status) {

      case "checked": {
        node[this.milestoneAttr].status = "unchecked";
        //use given node to evaluate data
        if (node[this.childrenAttr].length) { //parent

          for (var i = 0; i < node[this.childrenAttr].length; i++)
            node[this.childrenAttr][i][this.milestoneAttr].status = "unchecked";
        }
        else {
          //use nodes copy instead as this process will only give the selected node
          this.treeNodes.forEach(element => {
            if (element[this.childrenAttr].length === 1)
              // single child set to parent node to uncheck directly
              element[this.childrenAttr].find(child => { if (child.id === node.id) element[this.milestoneAttr].status = "unchecked" });
            else {
              // multiple children
              let count = 0;
              element[this.childrenAttr].find(child => {
                if (child[this.milestoneAttr].status === "checked") { count++; }
              });

              //if checked count already zero, then parent set directly to uncheck
              if (count === 0)
                element[this.childrenAttr].find(child => { if (child.id === node.id) element[this.milestoneAttr].status = "unchecked" });
              else // else parent is crossed
                element[this.childrenAttr].find(child => { if (child.id === node.id) element[this.milestoneAttr].status = "crossed" });
            }
          });
        }
        break;
      }
      case "unchecked": {
        node[this.milestoneAttr].status = "checked";
        if (node[this.childrenAttr].length) { //parent
          // set directy the child to checked
          for (var i = 0; i < node[this.childrenAttr].length; i++)
            node[this.childrenAttr][i][this.milestoneAttr].status = "checked";
        }
        else {
          this.treeNodes.forEach(element => {
            // single child set to parent node to check directly
            if (element[this.childrenAttr].length === 1)
              element[this.childrenAttr].find(child => { if (child.id === node.id) element[this.milestoneAttr].status = "checked" });
            else {
              // multiple children
              let count = 0;
              element[this.childrenAttr].find(child => {
                if (child[this.milestoneAttr].status === "checked") { count++; }
              });
              //if children checked status equal to number of children the set parent to checked directly
              if (count == element[this.childrenAttr].length)
                element[this.childrenAttr].find(child => { if (child.id === node.id) element[this.milestoneAttr].status = "checked" });
              else // if combination of checked and unchecks then set parent to crossed
                element[this.childrenAttr].find(child => { if (child.id === node.id) element[this.milestoneAttr].status = "crossed" });
            }
          });
        }
        break;
      }
      case "crossed": {
        node[this.milestoneAttr].status = "checked";
        if (node[this.childrenAttr].length) { //parent
          for (var i = 0; i < node[this.childrenAttr].length; i++)
            node[this.childrenAttr][i][this.milestoneAttr].status = "checked";
        }
        break;
      }
    }
    if (node[this.childrenAttr].length)
      this.onParentNodeCheck.emit(this.GetNodesCheckStatus(node, null, true)); // for parent check status events
    else {
      //this.interComponentMethodAccess.sendFunctionEvent(this.GetNodesCheckStatus(this.treeNodes, node, false)); // for children check status events
      this.envelop.set(this.GetNodesCheckStatus(this.treeNodes, node, false));
      this.emitDetails.messageEmitter.next(this.envelop);
    }
  }


  private GetNodesStatus(): NavTreeNodeStatus {
    let data = new NavTreeNodeStatus();
    let count = 0;
    for (let i = 0, len = this.nodes.length; i < len; i++) {
      count += (!this.nodes[i].isCollapsed) ? 1 : 0;
    }

    if (count === 0)
      data.AllNodesClosed = true;
    else
      data.AllNodesClosed = false;
    return data;

  }

  private GetNodesCheckStatus(node: any, selectedNode: any, isParent: boolean): NavTreeNodeStatus {
    let count = 0, countcheck = 0;
    let data = new NavTreeNodeStatus();
    data.CheckedStageIDArray = [];
    if (isParent) {
      if (node[this.childrenAttr].length) { //parent
        count += (node[this.milestoneAttr].status === "unchecked") ? 1 : 0;
        for (var i = 0; i < node[this.childrenAttr].length; i++)
          count += (node[this.childrenAttr][i][this.milestoneAttr].status === "unchecked") ? 1 : 0;
      }
      this.nodes.forEach(element => {
        element[this.childrenAttr].find(child => {
          if (child[this.milestoneAttr].status === "checked") {
            data.CheckedStageIDArray.push(child[this.idAttr]);
          }
        });
      });

      data.NodeId = node.id;
      data.NodeCheckStatus = node[this.milestoneAttr].status;
    }
    else {
      //check for the selected node first
      node.forEach(element => {
        //parent is either crossed or unchecked         
        count += ((element[this.milestoneAttr].status === "crossed" ||
          element[this.milestoneAttr].status === "unchecked") ? 1 : 0);
        countcheck += ((element[this.milestoneAttr].status === "checked") ? 1 : 0);
        //children is only unchecked    
        element[this.childrenAttr].find(child => {
          count += (child[this.milestoneAttr].status === "unchecked") ? 1 : 0;
        });

        element[this.childrenAttr].find(child => {
          countcheck += (child[this.milestoneAttr].status === "checked") ? 1 : 0;
          if (child[this.milestoneAttr].status === "checked")
            data.CheckedStageIDArray.push(child[this.idAttr]);
        });
      });
    }


    if (countcheck == 0)
      data.ChkMilestone = "unchecked";
    else {
      if (count == 0)
        data.ChkMilestone = "checked";
      else
        data.ChkMilestone = "crossed";
    }

    return data;

  }

  public changeDataByNodeId(nodeId: string, parentId: string) {
    if (nodeId == '' && parentId == '') {
      this._recursiveEdit(this.nodes, this.collapseAttr, true);
      this._recursiveEdit(this.nodes, this.selectedAttr, false);
      this.node = null;
    }
    else if (nodeId == '' && parentId != '') {
      this.node = this.getNodeById(this.nodes, parentId);
      this.selectedNode = true;
      this.collapseNode = true;
    } else if (nodeId != '' && parentId != '') {
      this.node = this.getNodeById(this.nodes, nodeId);
      this.selectedNode = true;
      let parentNode = this.getNodeById(this.nodes, parentId);
      this._recursiveEdit(this.nodes, this.collapseAttr, true);
      this._recursiveEditByNode(this.nodes, parentNode, this.collapseAttr, false);
    }
  }


  // Use for selecteAll and collapseAll
  private _recursiveEdit(list, attr, value) {
    if (Array.isArray(list)) {
      for (let i = 0, len = list.length; i < len; i++) {
        list[i][attr] = value;
        if (list[i][this.childrenAttr].length) {
          this._recursiveEdit(list[i][this.childrenAttr], attr, value);
        }
      }
    }
  }

  private _recursiveEditEx(list, attr1, attr2, value) {
    if (Array.isArray(list)) {
      for (let i = 0, len = list.length; i < len; i++) {
        list[i][attr1][attr2] = value;
        if (list[i][this.childrenAttr].length) {
          this._recursiveEditEx(list[i][this.childrenAttr], attr1, attr2, value);
        }
      }
    }
  }


  // Use for selected by node, collapsed by node
  private _recursiveEditByNode(list, node, attr, value) {
    if (Array.isArray(list)) {
      for (let i = 0, len = list.length; i < len; i++) {
        if (list[i][this.idAttr] == node[this.idAttr]) {
          list[i][attr] = value;
        }
        else if (list[i][this.childrenAttr].length) {
          this._recursiveEditByNode(list[i][this.childrenAttr], node, attr, value);
        }
      }
    }
  }

  private _preparedData(list) {
    //Only need for first time initialization
    for (let i = 0, len = list.length; i < len; i++) {
      list[i][this.collapseAttr] = true;
      list[i][this.selectedAttr] = false;
      list[i][this.milestoneAttr] = { status: this.interpretchkvlaues(list[i]['selected']) };
      list[i][this.checkBoxAttr] = false;
      if (list[i][this.childrenAttr]) {
        this._preparedData(list[i][this.childrenAttr]);
      } else {
        list[i][this.childrenAttr] = [];
      }
    }
    return list;


  }
  private interpretchkvlaues(data) {
    var interpret = "";
    switch (data) {
      case 0: interpret = 'unchecked'; break;
      case 1: interpret = 'checked'; break;
      case 2: interpret = 'crossed'; break;
    }
    return interpret;
  }

  private getNodeById(list, id: string) {
    let result = null;
    for (let i = 0, len = list.length; i < len; i++) {
      if (list[i][this.idAttr] === id) {
        result = list[i];
      } else if (list[i][this.childrenAttr].length) {
        result = this.getNodeById(list[i][this.childrenAttr], id);
      }

      if (result) break;
    }
    return result;
  }

  public getNodeDetails(name: string) {

    let result: Map<string, Map<string, string>>;
    result = new Map<string, Map<string, string>>();

    for (let i = 0, len = this.nodes.length; i < len; i++) {
      if (this.compare(this.nodes[i].name, name)) {
        this.createEntry(result, 'parent', 'stage', this.nodes[i].name, this.nodes[i].id);
        break;
      }
      let node = this.nodes[i];
      if (node.children.length > 0) {
        for (let j = 0, sublen = node.children.length; j < sublen; j++) {
          if (this.compare(node.children[j].name, name)) {
            this.createEntry(result, 'parent', 'stage', this.nodes[i].name, this.nodes[i].id);
            this.createEntry(result, 'child', 'setup', node.children[j].name, node.children[j].id);
            break;
          }
        }
      }
    }

    return result;
  }

  public getStageNode(name: string) {
    for (let i = 0, len = this.nodes.length; i < len; i++) {
      let node = this.nodes[i];
      if (node.children.length > 0) {
        for (let j = 0, sublen = node.children.length; j < sublen; j++) {
          if (this.compare(node.children[j].name, name)) {
            return node;
          }
        }
      }
    }
    return null;
  }



  private compare(strA: string, strB: string) {
    let resultA = strA;
    let resultB = strB;
    resultA = resultA.replace(/[^a-zA-Z0-9]/gi, "")
    resultB = resultB.replace(/%20|%28|%29|%2F/gi, "")
    resultB = resultB.replace(/[^a-zA-Z0-9]/gi, "")
    return (resultA === resultB);
  }

  private createEntry(result: Map<string, Map<string, string>>, key: string,
    prefixname: string,
    name: string,
    id: string) {

    let tempdata = new Map<string, string>();
    tempdata.set(`${prefixname}name`, name);
    tempdata.set(`${prefixname}id`, id);
    result.set(key, tempdata);
  }
}


