import { Component, OnInit, ViewChild, ElementRef, Input } from '@angular/core';
import { FirmwareService } from '../firmware.service';
import { Firmware } from '../shared/firmware.model';
import { PagerService } from 'src/app/core/pager/pager.service';
import { ActionResponse } from 'src/app/action-response/shared/action-response.model';
import { ToastrService } from 'ngx-toastr';
import { NgForm, ValidatorFn, AbstractControl } from '@angular/forms';
import { SearchFields, SearchField, SearchResult } from 'src/app/search/search.model';
import { DeviceService } from 'src/app/devices/device.service';
import { HttpParams } from '@angular/common/http';
import { SpinnerService } from 'src/app/spinner/spinner.service';
import { DeviceCommActions } from 'src/app/devices/shared/device-comm-actions';

@Component({
  selector: 'app-firmware-list',
  templateUrl: './firmware-list.component.html',
  styleUrls: ['./firmware-list.component.css']
})
export class FirmwareListComponent implements OnInit {
  @ViewChild('form') form;
  defaultStatus = '1';
  defaultMeterType = '24';
  fileSelected: File;
  firmwares: Firmware[];
  pager: any = {};
  pagedItems: Firmware[];
  actionResponse: ActionResponse;
  meterTypeDictionary: any = {};
  firmwareStatusDictionary: any = {};
  @ViewChild('myClose') myClose: ElementRef;
  searchModel: SearchFields = {};
  searchFields: SearchField[] = [];
  searchField: SearchField = {};
  onGoingUpload: boolean;
  onGoingUploadFW: string;
  toastrId: number;

  searchValues: SearchResult[] = [];
  commActions: DeviceCommActions;

  private formData: FormData;
  @ViewChild('uploadForm') uploadFirmwareForm: NgForm;
  constructor(public firmwareService: FirmwareService, private pagerService: PagerService,
    private toastrService: ToastrService, private deviceService: DeviceService,
    public spinnerService: SpinnerService) {
      this.commActions = new DeviceCommActions(deviceService);
    }

  ngOnInit() {

    this.onGetFirmwares();
    this.generateSearchComponent();
    this.meterTypeDictionary = this.deviceService.getMeterTypeDictionary();

    this.firmwareStatusDictionary['Inactive'] = '0';
    this.firmwareStatusDictionary['Active'] = '1';

    this.onGoingUploadFW = 'onGoingUploadFW';
    this.toastrId = 4819;

    if (localStorage.getItem(this.onGoingUploadFW) != null || (localStorage.getItem(this.onGoingUploadFW) === 'true')) {
      this.showOngoingUploadToastr();
    }
  }

  onUploadFirmware() {
    this.showOngoingUploadToastr();

    this.formData = new FormData();
    this.formData.append('FWCode', this.uploadFirmwareForm.value.fwcode.trim());
    this.formData.append('FWName', this.uploadFirmwareForm.value.fwname.trim());
    this.formData.append('FWVersion', this.uploadFirmwareForm.value.fwversion.trim());
    this.formData.append('FWEdition', this.uploadFirmwareForm.value.fwedition.trim());
    this.formData.append('deviceTypeId', this.uploadFirmwareForm.value.fwdevicetype);
    this.formData.append('FWDescription', this.uploadFirmwareForm.value.fwdescription !== null ?
      this.uploadFirmwareForm.value.fwdescription.trim() : '');
    this.formData.append('Status', this.uploadFirmwareForm.value.fwstatus);
    this.formData.append('FWImage', this.fileSelected);
    console.log(this.formData);
    this.firmwareService.uploadFirmware(this.formData).subscribe((actionResponse) => {
      this.actionResponse = actionResponse;
    },
      (error: any) => {
        this.resetFiles();
        console.log(error);
        this.showErrorUploadToastr(error);
      },
      () => {
        this.resetFiles();
        this.processImportedFirmwares();
      });
  }

  openModal($event) {
    this.fileSelected = null;
    if ($event.target.files[0]) {
      document.getElementById('uploadFirmwareModal').click();
      this.fileSelected = $event.target.files[0];
      this.isValidFile();
    }
  }

  activateUploadButton() {
    if (!this.uploadFirmwareForm.invalid && this.fileSelected != null) {
      return true;
    } else {
      return false;
    }
  }

  onSelectFile($event) {
    this.fileSelected = null;
    if ($event.target.files[0]) {
      this.fileSelected = $event.target.files[0];
    }

  }

  onGetFirmwares(refresh = false, search: SearchResult[] = null) {
    this.pager = [];
    this.firmwares = [];

    let params = new HttpParams();

    if (search !== null) {
      this.searchValues = search;
    }

    // Begin assigning parameters
    if (this.searchValues !== null) {
      for (let i = 0; i < this.searchValues.length; i++) {
        params = params.append(this.searchValues[i].Name, this.searchValues[i].Value);
      }
    }

    this.firmwareService.getFirmwares(refresh, params).subscribe((firmwares) => {
      this.firmwares = firmwares.firmwares;
      this.setPage(1);
    });

    this.commActions.autoDisconnectLastConnection();
  }

  setPage(page: number) {
    // get pager object from service
    this.pager = this.pagerService.getPager(this.firmwares.length, page);

    // get current page of items
    this.pagedItems = this.firmwares.slice(this.pager.startIndex, this.pager.endIndex + 1);
  }

  resetFiles() {
    this.onGoingUpload = false;
    this.form.nativeElement.reset();
    this.fileSelected = null;
  }

  processImportedFirmwares() {
    localStorage.removeItem(this.onGoingUploadFW);
    this.toastrService.remove(this.toastrId);
    this.showCompleteUploadToastr();
  }

  onCloseModal(event: any) {
    const el: HTMLElement = this.myClose.nativeElement as HTMLElement;
    el.click();
  }

  generateSearchComponent() {
    // Note: When creating this object, be mindful of the order you're creating it with.
    // KeyValue pipe returns key-value pair in alphabetical order for strings, ascending for numbers

    // Search Values
    this.searchField.Name = 'FWCode';
    this.searchField.Description = 'Firmware Code';
    this.searchField.FieldType = 'Search';
    this.searchField.PlaceHolder = 'Search Firmwares';
    this.searchFields.push(this.searchField);

    this.searchField = {};
    this.searchField.Name = 'FWName';
    this.searchField.Description = 'Firmware Name';
    this.searchField.FieldType = 'Search';
    this.searchField.PlaceHolder = 'Search Firmwares';
    this.searchFields.push(this.searchField);

    // Filters
    this.searchField = {};
    this.searchField.Name = 'DeviceTypeId';
    this.searchField.Description = 'Device Type';
    this.searchField.FieldType = 'Filter';
    this.searchField.PlaceHolder = 'All Device Type';
    this.searchField.OptionValues = this.deviceService.getMeterTypeDictionary();
    this.searchFields.push(this.searchField);

    this.searchModel.SearchFields = this.searchFields;
  }

  showOngoingUploadToastr() {
    this.toastrService.remove(this.toastrId); // clean up first before showing another
    this.onGoingUpload = true; // temporarily disable other fw uploads when an upload is ongoing
    this.toastrService.info('Firmware Import/Upload', 'Firmware Import Ongoing', {
      easeTime: 300,
      timeOut: 10000,
      closeButton: true,
      tapToDismiss: false,
      positionClass: 'toast-bottom-left'
    }).toastId = this.toastrId;
  }

  showErrorUploadToastr(error: any) {
    this.toastrService.remove(this.toastrId); // clean up first before showing another
    this.resetFiles();
    this.toastrService.error(error.error.message, 'Firmware Import Failed', {
      easeTime: 300,
      timeOut: 10000,
      closeButton: true,
      tapToDismiss: false,
      positionClass: 'toast-bottom-left'
    });
  }

  showCompleteUploadToastr() {
    this.toastrService.success('Refresh to update list', 'Firmware Import Complete', {
      enableHtml: true,
      easeTime: 300,
      timeOut: 10000,
      closeButton: true,
      tapToDismiss: false,
      positionClass: 'toast-bottom-left'
    });
  }

  clearInputValues() {
    this.uploadFirmwareForm.resetForm({
      fwdevicetype: this.defaultMeterType,
      fwstatus: this.defaultStatus
    });
  }

  isValidFile() {
    const ext = this.fileSelected.name.substring(this.fileSelected.name.lastIndexOf('.'));
    if (ext.toLowerCase() === '.bin') {
      return true;
    } else {
      this.uploadFirmwareForm.controls['fwimagefile'].setErrors({ 'invalidFile': true });
      this.uploadFirmwareForm.controls['fwimagefile'].markAsDirty();
      return false;
    }
  }

  public getErrorMessage(value: string, fieldName: string, required: boolean, textPattern: string = '', validCharacterList: string = '') {
    // invalid input is detected, return appropriate message
    if (value === '' && required) {
      return fieldName + ' cannot be blank';
    } else if (!value.match(this.getTextPatternValidator(false, textPattern))) {
      if (validCharacterList !== '') {
        return 'Value contains invalid characters. <br/> Valid characters are: ' + validCharacterList;
      }
      return 'Value contains invalid characters. <br/> Valid characters are: A-Z a-z 0-9 - _ # .';
    }
    return fieldName + ' is invalid';
  }

  getTextPatternValidator(alphaNumeric: boolean, textPattern: string = '') {
    if (textPattern !== '') {
      return textPattern;
    }

    if (!alphaNumeric) {
      return ('^[a-zA-Z0-9-_#.]*$');
    } else {
      return ('^[a-zA-Z0-9]*$');
    }
  }

  public omit_invalid_characters(event, alphaNumeric: boolean, textPattern: string = '') {
    const key = event.charCode;

    if (textPattern !== '' && textPattern !== undefined) {
      if (event.key.match(RegExp(textPattern))) {
        return key;
      }
    }


    if (!alphaNumeric) {
      return ((key >= 48 && key <= 57) || (key >= 65 && key <= 90) || (key >= 97 && key <= 122) || key === 45 ||
        key === 95 || key === 46 || key === 35);
    } else {
      return ((key >= 48 && key <= 57) || (key >= 65 && key <= 90) || (key >= 97 && key <= 122));
    }
  }
}

